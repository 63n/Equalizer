Index: tests/accept/accept.cpp
===================================================================
--- tests/accept/accept.cpp	(revision 3640)
+++ tests/accept/accept.cpp	(working copy)
@@ -163,8 +163,9 @@
                     break;
 
                 case ConnectionSet::EVENT_SELECT_ERROR:
-                    OUTPUT << "Error during select, " << connectionSet.size() 
-                        << " connections open" << std::endl;
+                    OUTPUT << "Error during select, " 
+                           << connectionSet.getSize() << " connections open"
+                           << std::endl;
                     break;
 
                 case ConnectionSet::EVENT_DATA:
@@ -190,7 +191,7 @@
             if( time > 1000.0f )
             {
                 OUTPUT << nConnects / time * 1000.f << " accepts/s, "
-                       << connectionSet.size() << " connections open"
+                       << connectionSet.getSize() << " connections open"
                        << std::endl;
                 nConnects = 0;
                 clock.reset();
Index: tests/netperf/netperf.cpp
===================================================================
--- tests/netperf/netperf.cpp	(revision 3640)
+++ tests/netperf/netperf.cpp	(working copy)
@@ -263,7 +263,7 @@
                 }
             }
             TESTINFO( _receivers.empty(), _receivers.size() );
-            TESTINFO( _connectionSet.size() == 1, _connectionSet.size() );
+            TESTINFO( _connectionSet.getSize() == 1, _connectionSet.getSize( ));
             _connectionSet.clear();
             return EXIT_SUCCESS;
         }
Index: lib/net/connectionSet.cpp
===================================================================
--- lib/net/connectionSet.cpp	(revision 3640)
+++ lib/net/connectionSet.cpp	(working copy)
@@ -33,9 +33,12 @@
 #ifdef WIN32
 #  define SELECT_TIMEOUT WAIT_TIMEOUT
 #  define SELECT_ERROR   WAIT_FAILED
+#  define BIG_CLUSTER_SUPPORT
+#  define MAX_CONNECTIONS (MAXIMUM_WAIT_OBJECTS - 1)
 #else
 #  define SELECT_TIMEOUT  0
 #  define SELECT_ERROR   -1
+#  define MAX_CONNECTIONS EQ_100KB  // Arbitrary
 #endif
 
 namespace eq
@@ -44,7 +47,13 @@
 {
 
 ConnectionSet::ConnectionSet()
-        : _selfCommand( 0 )
+#ifdef WIN32
+        : _thread( 0 ),
+#else
+        :
+#endif
+          _selfConnection( new PipeConnection )
+        , _selfCommand( 0 )
         , _error( 0 )
         , _dirty( true )
 {
@@ -52,10 +61,10 @@
     // connection set is waiting in a select, the select is interrupted by
     // sending a character through this connection. select() will recognize
     // this and restart with the modified fd set.
-    _selfConnection = new PipeConnection;
+    // OPT: On Win32, we could just use an event handle
     if( !_selfConnection->connect( ))
     {
-        EQERROR << "Could not create connection" << std::endl;
+        EQERROR << "Could not create self connection" << std::endl;
         return;
     }
     _selfConnection->recvNB( &_selfCommand, sizeof( _selfCommand ));
@@ -63,6 +72,8 @@
 
 ConnectionSet::~ConnectionSet()
 {
+    clear();
+
     _connection = 0;
 
     _selfConnection->close();
@@ -75,9 +86,8 @@
     if( _dirty )
         return;
 
-    EQINFO << "FD set modified, restarting select" << std::endl;
+    EQVERB << "FD set modified, restarting select" << std::endl;
     _dirty = true;
-
     interrupt();
 }
 
@@ -93,13 +103,48 @@
 void ConnectionSet::addConnection( ConnectionPtr connection )
 {
     EQASSERT( connection->isConnected() || connection->isListening( ));
-    {
+    EQASSERT( _allConnections.size() < MAX_CONNECTIONS * MAX_CONNECTIONS );
+
+    { 
         base::ScopedMutex mutex( _mutex );
-        EQASSERTINFO( _connections.size() < 63,
-            "Connection set can't handle more than 63 connections" );
+        _allConnections.push_back( connection );
+
+#ifdef BIG_CLUSTER_SUPPORT
+        if( _connections.size() < MAX_CONNECTIONS - _threads.size( ))
+        {   // can handle it ourself
+            _connections.push_back( connection );
+            connection->addListener( this );
+        }
+        else
+        {
+            // add to existing thread
+            for( ThreadVector::const_iterator i = _threads.begin();
+                 i != _threads.end(); ++i )
+            {
+                Thread* thread = *i;
+                if( thread->set->getSize() > MAX_CONNECTIONS )
+                    continue;
+
+                thread->set->addConnection( connection );
+                return;
+            }
+
+            // add to new thread
+            Thread* thread = new Thread( this );
+            thread->set->addConnection( connection );
+            thread->set->addConnection( _connections.back( ));
+            _connections.pop_back();
+
+            _threads.push_back( thread );
+            thread->start();
+        }
+#else
         _connections.push_back( connection );
         connection->addListener( this );
+#endif
+        EQASSERT( _connections.size() < MAX_CONNECTIONS );
     }
+
     _dirtyFDSet();
 }
 
@@ -107,17 +152,48 @@
 {
     {
         base::ScopedMutex mutex( _mutex );
-        ConnectionVector::iterator i = find( _connections.begin(),
-                                             _connections.end(), connection );
-        if( i == _connections.end( ))
+        ConnectionVector::iterator i = find( _allConnections.begin(),
+                                             _allConnections.end(), connection);
+        if( i == _allConnections.end( ))
             return false;
 
-        connection->removeListener( this );
-        _connections.erase( i );
-    }
+        if( _connection == connection )
+            _connection = 0;
 
-    if( _connection == connection )
-        _connection = 0;
+        ConnectionVector::iterator j = find( _connections.begin(),
+                                             _connections.end(), connection );
+        if( j == _connections.end( ))
+        {
+#ifdef BIG_CLUSTER_SUPPORT
+            ThreadVector::iterator k = _threads.begin();
+            for( ; k != _threads.end(); ++k )
+            {
+                Thread* thread = *k;
+                if( thread->set->removeConnection( connection ))
+                {
+                    if( !thread->set->isEmpty( ))
+                        return true;
+
+                    thread->join();
+                    delete thread;
+                    break;
+                }
+            }
+
+            EQASSERT( k != _threads.end( ));
+            _threads.erase( k );
+#else
+            EQUNREACHABLE;
+#endif
+        }
+        else
+        {
+            _connections.erase( j );
+            connection->removeListener( this );
+        }
+
+        _allConnections.erase( i );
+    }
 
     _dirtyFDSet();
     return true;
@@ -126,23 +202,78 @@
 void ConnectionSet::clear()
 {
     _connection = 0;
+
+#ifdef BIG_CLUSTER_SUPPORT
+    for( ThreadVector::iterator i = _threads.begin(); i != _threads.end(); ++i )
+    {
+        Thread* thread = *i;
+        thread->set->clear();
+        thread->join();
+        delete thread;
+    }
+    _threads.clear();
+#endif;
+
     for( ConnectionVector::iterator i = _connections.begin(); 
          i != _connections.end(); ++i )
-
+    {
         (*i)->removeListener( this );
+    }
 
+    _allConnections.clear();
     _connections.clear();
     _dirtyFDSet();
     _fdSet.clear();
-    _fdSetConnections.clear();
+    _fdSetResult.clear();
 }
-        
+
+#ifdef BIG_CLUSTER_SUPPORT
+ConnectionSet::Thread::Thread( ConnectionSet* parent )
+        : set( new ConnectionSet )
+        , notifier( CreateEvent( 0, false, false, 0 ))
+        , event( EVENT_NONE )
+        , _parent( parent )
+{
+   
+}
+
+ConnectionSet::Thread::~Thread()
+{
+    delete set;
+    set = 0;
+}
+
+
+void* ConnectionSet::Thread::run()
+{
+    while ( !set->isEmpty( ))
+    {
+        event.waitEQ( EVENT_NONE );
+      again:
+        event = set->select( INFINITE );
+        if( event == EVENT_INTERRUPT || event == EVENT_NONE )
+            goto again;
+
+        SetEvent( notifier );
+    }
+
+    return EXIT_SUCCESS;
+}
+#endif
+
 ConnectionSet::Event ConnectionSet::select( const int timeout )
 {
     while( true )
     {
         _connection = 0;
         _error      = 0;
+#ifdef BIG_CLUSTER_SUPPORT
+        if( _thread )
+        {
+            _thread->event = EVENT_NONE; // unblock previous thread
+            _thread = 0;
+        }
+#endif
 
         if( !_setupFDSet( ))
             return EVENT_INVALID_HANDLE;
@@ -163,7 +294,11 @@
 
             case SELECT_ERROR:
 #ifdef WIN32
-                _error = GetLastError();
+#  ifdef BIG_CLUSTER_SUPPORT
+                if( !_thread )
+#  endif
+                    _error = GetLastError();
+
                 if( _error == WSA_INVALID_HANDLE )
                 {
                     _dirty = true;
@@ -200,8 +335,7 @@
                         event = EVENT_CONNECT;
 
                     EQVERB << "selected connection " << _connection << " of "
-                           << _fdSetConnections.getSize() << ", event " << event
-                           << std::endl;
+                           << getSize() << ", event " << event << std::endl;
                     return event;
                 }
         }
@@ -212,10 +346,23 @@
 {
 #ifdef WIN32
     const uint32_t i = index - WAIT_OBJECT_0;
-    if( i >= MAXIMUM_WAIT_OBJECTS )
-        return EVENT_INTERRUPT;
+    EQASSERT( i < MAXIMUM_WAIT_OBJECTS );
+    EQASSERT( i < _fdSetResult.getSize( ));
+
+    if( i >= _connections.size( ))
+    {
+        Thread* thread = _fdSetResult[i].thread;
+        EQASSERT( thread->event == EVENT_NONE );
+        EQASSERT( _fdSet[ i ] == thread->notifier );
+        
+        ResetEvent( _thread->notifier ); 
+        _connection = thread->set->getConnection();
+        _error = thread->set->getError();
+        return thread->event.get();
+    }
+    // else locally handled connection
 
-    _connection = _fdSetConnections[i];
+    _connection = _fdSetResult[i].connection;
     EQASSERT( _fdSet[i] == _connection->getNotifier( ));
 
     return EVENT_DATA;
@@ -229,7 +376,7 @@
         const int pollEvents = pollFD.revents;
         EQASSERT( pollFD.fd > 0 );
 
-        _connection = _fdSetConnections[i];
+        _connection = _fdSetResult[i].connection;
         EQASSERT( _connection.isValid( ));
 
         EQVERB << "Got event on connection @" << (void*)_connection.get()
@@ -295,15 +442,17 @@
 
     _dirty = false;
     _fdSet.setSize( 0 );
-    _fdSetConnections.setSize( 0 );
+    _fdSetResult.setSize( 0 );
 
 #ifdef WIN32
     // add self connection
     HANDLE readHandle = _selfConnection->getNotifier();
     EQASSERT( readHandle );
-
     _fdSet.append( readHandle );
-    _fdSetConnections.append( _selfConnection.get( ));
+
+    Result result;
+    result.connection = _selfConnection.get();;
+    _fdSetResult.append( result );
 
     // add regular connections
     _mutex.set();
@@ -323,7 +472,22 @@
         }
         
         _fdSet.append( readHandle );
-        _fdSetConnections.append( connection.get( ));
+
+        Result result;
+        result.connection = connection.get();;
+        _fdSetResult.append( result );
+    }
+    for( ThreadVector::const_iterator i = _threads.begin();
+         i != _threads.end(); ++i )
+    {
+        Thread* thread = *i;
+        readHandle = thread->notifier;
+        EQASSERT( readHandle );
+        _fdSet.append( readHandle );
+
+        Result result;
+        result.thread = thread;
+        _fdSetResult.append( result );
     }
     _mutex.unset();
 #else
@@ -334,9 +498,11 @@
     fd.fd      = _selfConnection->getNotifier();
     EQASSERT( fd.fd > 0 );
     fd.revents = 0;
-
     _fdSet.append( fd );
-    _fdSetConnections.append( _selfConnection.get( ));
+
+    Result result;
+    result.connection = _selfConnection.get();
+    _fdSetResult.append( result );
 
     // add regular connections
     _mutex.set();
@@ -361,7 +527,9 @@
         fd.revents = 0;
 
         _fdSet.append( fd );
-        _fdSetConnections.append( connection.get( ));
+
+        result.connection = connection.get();
+        _fdSetResult.append( result );
     }
     _mutex.unset();
     _fdSetCopy = _fdSet;
Index: lib/net/node.cpp
===================================================================
--- lib/net/node.cpp	(revision 3640)
+++ lib/net/node.cpp	(working copy)
@@ -107,7 +107,7 @@
 {
     EQINFO << "Delete Node @" << (void*)this << " " << _id << std::endl;
     EQASSERT( _outgoing == 0 );
-    EQASSERT( _incoming.empty( ));
+    EQASSERT( _incoming.isEmpty( ));
     EQASSERT( _connectionNodes.empty( ));
     EQASSERT( _pendingCommands.empty( ));
     EQASSERT( _nodes.empty( ));
@@ -347,7 +347,7 @@
     EQCHECK( _receiverThread->join( ));
     _cleanup();
 
-    EQINFO << _incoming.size() << " connections open after stopListening"
+    EQINFO << _incoming.getSize() << " connections open after stopListening"
            << std::endl;
 #ifndef NDEBUG
     const ConnectionVector& connections = _incoming.getConnections();
Index: lib/net/connectionSet.h
===================================================================
--- lib/net/connectionSet.h	(revision 3640)
+++ lib/net/connectionSet.h	(working copy)
@@ -18,14 +18,23 @@
 #ifndef EQNET_CONNECTION_SET_H
 #define EQNET_CONNECTION_SET_H
 
+#ifdef EQUALIZER_EXPORTS
+   // We need to instantiate a Monitor< Event > when compiling the library,
+   // but we don't want to have <pthread.h> for a normal build, hence this hack
+#  include <pthread.h>
+#endif
+
 #include <eq/net/connectionListener.h> // base class
 
 #include <eq/base/base.h>
 #include <eq/base/buffer.h>
 #include <eq/base/hash.h>
+#include <eq/base/monitor.h>
 #include <eq/base/refPtr.h>
 
-#ifndef WIN32
+#ifdef WIN32
+#  include <eq/base/thread.h>
+#else
 #  include <poll.h>
 #endif
 
@@ -65,10 +74,10 @@
         EQ_EXPORT void addConnection( ConnectionPtr connection );
         EQ_EXPORT bool removeConnection( ConnectionPtr connection );
         EQ_EXPORT void clear();
-        size_t size()  const { return _connections.size(); }
-        bool   empty() const { return _connections.empty(); }
+        size_t getSize()  const { return _connections.size(); }
+        bool   isEmpty() const { return _connections.empty(); }
 
-        const ConnectionVector& getConnections() const { return _connections; }
+        const ConnectionVector& getConnections() const{ return _allConnections;}
 
         /** 
          * Selects a Connection which is ready for I/O.
@@ -91,9 +100,54 @@
         ConnectionPtr getConnection(){ return _connection; }
 
     private:
+ 
+#ifdef WIN32
+        /** Handles connections exceeding MAXIMUM_WAIT_OBJECTS */
+        class Thread : public eq::base::Thread
+        {
+        public:
+            Thread( ConnectionSet* parent );
+            virtual ~Thread();
+
+            ConnectionSet* set;
+            HANDLE         notifier;
+            
+            base::Monitor< Event > event;
+
+        protected:
+            virtual void* run();
+
+        private:
+            ConnectionSet* const _parent;
+        };
+
+
+        typedef std::vector< Thread* > ThreadVector;
+        /** Threads used to handle more than MAXIMUM_WAIT_OBJECTS connections */
+        ThreadVector _threads;
+
+        /** Result thread. */
+        Thread* _thread;
+
+        union Result
+        {
+            Connection* connection;
+            Thread* thread;
+        };
+
+#else
+        union Result
+        {
+            Connection* connection;
+        };
+#endif
+
         /** Mutex protecting changes to the set. */
         base::Lock _mutex;
 
+        /** The connections of this set */
+        ConnectionVector _allConnections;
+
         /** The connections to handle */
         ConnectionVector _connections;
 
@@ -104,7 +158,7 @@
         base::Buffer< pollfd > _fdSetCopy; // 'const' set
         base::Buffer< pollfd > _fdSet;     // copy of _fdSetCopy used to poll
 #endif
-        base::Buffer< Connection* > _fdSetConnections;
+        base::Buffer< Result > _fdSetResult;
 
         /** The connection to reset a running select, see constructor. */
         base::RefPtr< PipeConnection > _selfConnection;
