Index: lib/net/connectionSet.cpp
===================================================================
--- lib/net/connectionSet.cpp	(revision 3154)
+++ lib/net/connectionSet.cpp	(working copy)
@@ -41,6 +41,7 @@
 #ifdef WIN32
 #  define SELECT_TIMEOUT WAIT_TIMEOUT
 #  define SELECT_ERROR   WAIT_FAILED
+#  define EQ_MAXIMUM_WAIT_OBJECTS MAXIMUM_WAIT_OBJECTS
 #else
 #  define SELECT_TIMEOUT  0
 #  define SELECT_ERROR   -1
@@ -55,6 +56,9 @@
         : _selfCommand( 0 )
         , _error( 0 )
         , _dirty( true )
+#ifdef WIN32
+        , _threadQueueEvent( CreateEvent( 0, false, false, 0 ))
+#endif
 {
     // Whenever another threads modifies the connection list while the
     // connection set is waiting in a select, the select is interrupted by
@@ -100,16 +104,113 @@
     EQASSERT( connection->isConnected() || connection->isListening( ));
     {
         base::ScopedMutex mutex( _mutex );
-        EQASSERTINFO( _connections.size() < 63,
-            "Connection set can't handle more than 63 connections" );
+		
         _connections.push_back( connection );
-        connection->addListener( this );
+#ifdef WIN32
+        if( _connections.size() <= EQ_MAXIMUM_WAIT_OBJECTS - 2 )
+        {
+            connection->addListener( this );
+            _dirtyFDSet();
+            return;
+        }
+
+        for( ThreadVector::const_iterator i = _threads.begin();
+             i != _threads.end(); ++i )
+        {
+            Thread* thread = *i;
+            if ( thread->connectionSet->getConnections().size() <
+                 EQ_MAXIMUM_WAIT_OBJECTS-2 )
+            {
+                thread->connectionSet->addConnection( connection );
+                return;
+            }
+        }
+
+        Thread* thread = new Thread( this );
+        thread->connectionSet->addConnection( connection );
+        _threads.push_back( thread );
+        thread->start();
+#endif
     }
     _dirtyFDSet();
 }
 
 bool ConnectionSet::removeConnection( ConnectionPtr connection )
 {
+#ifdef WIN32
+    ScopedMutex mutex( _mutex ); 
+    ConnectionVector::iterator i = find( _connections.begin(),
+                                         _connections.end(), connection );
+    if( i == _connections.end( ))
+        return false;
+        
+    const size_t index = i - _connections.begin();
+
+    if( index >= EQ_MAXIMUM_WAIT_OBJECTS - 2 )
+    {
+        // We are the master set and don't handle it ourselves
+        EQASSERT( !_threads.empty( ));
+
+        for( ThreadVector::iterator j = _threads.begin();
+             j != _threads.end(); ++j )
+        {
+            Thread* thread = *j;
+            if( thread->connectionSet->removeConnection( connection ))
+            {
+                // remove thread if no connections left
+                if ( thread->connectionSet->empty( ))
+                {
+                    thread->join();
+                    _threads.erase( j );
+                    delete thread; 
+                }
+                break;
+            }
+        }
+    }
+    else
+    {
+        connection->removeListener( this );
+
+        if( _threads.empty( ))
+        {
+            // We are the slave or standalone master
+            EQASSERT( _threads.empty( ));
+        }
+        else
+        {
+            // We are the master connection set, and we handle the connection
+            // -> steal a connection from a thread to keep our list full
+            ThreadVector::iterator i = _threads.begin();
+
+            Thread* thread = *i;
+            EQASSERT( !thread->connectionSet->empty( ));
+            
+            ConnectionPtr moveConnection =
+                thread->connectionSet->getConnections().back();
+            
+            thread->connectionSet->removeConnection( moveConnection );
+            _connections[ index ] = moveConnection;
+            
+            // remove thread if no connections left
+            if ( thread->connectionSet->empty( ))
+            {
+                thread->join();
+                _threads.erase( i );
+                delete thread;
+            }
+        }
+    }
+         
+    _connections.erase( i );
+
+    if( _connection == connection )
+        _connection = 0;
+
+    _dirtyFDSet();
+    return true;
+
+#else
     {
         ScopedMutex mutex( _mutex );
         ConnectionVector::iterator i = find( _connections.begin(),
@@ -126,11 +227,23 @@
 
     _dirtyFDSet();
     return true;
+#endif;
 }
 
 void ConnectionSet::clear()
 {
     _connection = 0;
+
+#ifdef WIN32
+    for ( ThreadVector::iterator j = _threads.end(); 
+              j != _threads.begin(); j-- )
+    {
+        (*j)->connectionSet->clear();
+        delete (*j);
+    }
+    _threads.clear();
+#endif;
+
     for( ConnectionVector::iterator i = _connections.begin(); 
          i != _connections.end(); ++i )
 
@@ -141,7 +254,47 @@
     _fdSet.clear();
     _fdSetConnections.clear();
 }
+
+#ifdef WIN32
+
+ConnectionSet::Thread::Thread( ConnectionSet* parent )
+        : connectionSet( new ConnectionSet ), 
+          _parent( parent )
+{
+   
+}
+
+ConnectionSet::Thread::~Thread()
+{
+    delete connectionSet;
+}
+
+
+void* ConnectionSet::Thread::run()
+{
+    while ( !connectionSet->empty( ) )
+    {
+        Event eventSelect = connectionSet->select( INFINITE );
+        QueueEvent queueEvent;
+        queueEvent.event       = eventSelect;
+        queueEvent.connection = connectionSet->getConnection();
+        queueEvent.error       = connectionSet->getError();
         
+        if (!( queueEvent.event == EVENT_INTERRUPT && !queueEvent.connection ))
+            _parent->_queueEvent( queueEvent );
+    }
+
+    return EXIT_SUCCESS;
+}
+
+void ConnectionSet::_queueEvent( const QueueEvent& queueEvent )
+{
+    base::ScopedMutex mutex( _queueMutex ); 
+    _queueEvents.push_front( queueEvent );
+    SetEvent( _threadQueueEvent );
+}
+#endif;
+
 ConnectionSet::Event ConnectionSet::select( const int timeout )
 {
     while( true )
@@ -155,8 +308,24 @@
         // poll for a result
 #ifdef WIN32
         const DWORD waitTime = timeout > 0 ? timeout : INFINITE;
-        const DWORD ret = WaitForMultipleObjectsEx( _fdSet.size, _fdSet.data,
-                                                    FALSE, waitTime, TRUE );
+        {
+            base::ScopedMutex mutex( _queueMutex ); 
+            if ( !_queueEvents.empty() )
+            {
+                ResetEvent( _threadQueueEvent );  
+                QueueEvent queueEvent = _queueEvents.back();
+                _queueEvents.pop_back();
+                _connection = queueEvent.connection;
+                _error      = queueEvent.error;
+                return queueEvent.event;
+            }
+        }
+        const DWORD ret = WaitForMultipleObjectsEx( 
+                        EQ_MIN ( _fdSet.size, EQ_MAXIMUM_WAIT_OBJECTS ), 
+                                 _fdSet.data, FALSE, waitTime, TRUE );
+
+        
+
 #else
         const int ret = poll( _fdSet.data, _fdSet.size, timeout );
 #endif
@@ -215,12 +384,24 @@
 {
 #ifdef WIN32
     const uint32_t i = index - WAIT_OBJECT_0;
-    if( i >= MAXIMUM_WAIT_OBJECTS )
-        return EVENT_INTERRUPT;
 
+    {
+        base::ScopedMutex mutex( _queueMutex ); 
+        if( i == EQ_MAXIMUM_WAIT_OBJECTS - 1 ) // queue
+        {
+            ResetEvent( _threadQueueEvent );               
+            const QueueEvent queueEvent = _queueEvents.back();
+            _queueEvents.pop_back();
+            _connection = queueEvent.connection;
+            _error = queueEvent.error;
+            return queueEvent.event;
+        }
+    }
+
+    EQASSERT( i < EQ_MAXIMUM_WAIT_OBJECTS );
     _connection = _fdSetConnections[i];
-    EQASSERT( _fdSet[i] == _connection->getNotifier( ));
 
+    EQASSERT( _fdSet[i] == _connection->getNotifier( ));
     return EVENT_DATA;
 #else
     for( size_t i = 0; i < _fdSet.size; ++i )
@@ -327,6 +508,12 @@
         
         _fdSet.append( readHandle );
         _fdSetConnections.append( connection.get( ));
+        if ( _fdSet.size == EQ_MAXIMUM_WAIT_OBJECTS -1 )
+        {
+            _fdSetConnections.append( 0 );
+            _fdSet.append( _threadQueueEvent );
+            break;
+        }
     }
     _mutex.unset();
 #else
Index: lib/net/connectionSet.h
===================================================================
--- lib/net/connectionSet.h	(revision 3154)
+++ lib/net/connectionSet.h	(working copy)
@@ -27,6 +27,9 @@
 
 #ifndef WIN32
 #  include <poll.h>
+#else
+#  include <eq/base/thread.h>
+#  include <Queue>
 #endif
 
 namespace eq
@@ -90,6 +93,49 @@
         ConnectionPtr getConnection(){ return _connection; }
 
     private:
+ 
+#ifdef WIN32
+        struct QueueEvent
+        {
+            QueueEvent() : event( EVENT_NONE ), error( 0 ) {}
+
+            Event event;
+            ConnectionPtr connection;
+            int error;
+        };
+
+        /** Handles connections exceeding MAXIMUM_WAIT_OBJECTS */
+        class Thread : public eq::base::Thread
+        {
+        public:
+            Thread( ConnectionSet* parent );
+            virtual ~Thread();
+
+            ConnectionSet* connectionSet;
+
+        protected:
+            virtual void* run();
+
+        private:
+            ConnectionSet* const _parent;
+        };
+        typedef std::vector< Thread* > ThreadVector;
+        /* Allow MAXIMUM_WAIT_OBJECTS for each WaitThread */
+        ThreadVector _threads;
+
+        /* A queue for have all event from each WaitThread */
+        std::deque< QueueEvent > _queueEvents;
+
+        /* An event when an event is added in queueEvents */
+        HANDLE _threadQueueEvent;
+        
+        /** Mutex protecting changes in the queue. */
+        base::Lock _queueMutex;
+
+        /* add an event in the queue */
+        void _queueEvent( const QueueEvent& queueEvent );
+
+#endif
         /** Mutex protecting changes to the set. */
         base::Lock _mutex;
 
