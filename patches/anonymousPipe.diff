diff --git a/libs/collage/connectionSet.cpp b/libs/collage/connectionSet.cpp
index 5f56e94..f8bdeb9 100644
--- a/libs/collage/connectionSet.cpp
+++ b/libs/collage/connectionSet.cpp
@@ -358,6 +358,10 @@ ConnectionSet::Event ConnectionSet::_getSelectResult( const uint32_t index )
     // else locally handled connection
 
     _connection = _fdSetResult[i].connection;
+
+    if( _connection->isClosed() )
+        return EVENT_NONE;
+
     EQASSERT( _fdSet[i] == _connection->getNotifier( ));
 
     return EVENT_DATA;
diff --git a/libs/collage/connectionType.h b/libs/collage/connectionType.h
index 0fc32a4..6735f4a 100644
--- a/libs/collage/connectionType.h
+++ b/libs/collage/connectionType.h
@@ -80,6 +80,10 @@ namespace co
                 os << "RSP";
                 break;
                 
+            case CONNECTIONTYPE_NONE:
+                os << "NONE";
+                break;
+                
             default:
                 EQASSERTINFO( false, "Not implemented" );
                 os << "ERROR";
diff --git a/libs/collage/namedPipeConnection.cpp b/libs/collage/namedPipeConnection.cpp
index c873532..96f33c5 100644
--- a/libs/collage/namedPipeConnection.cpp
+++ b/libs/collage/namedPipeConnection.cpp
@@ -74,7 +74,14 @@ bool NamedPipeConnection::connect()
     _state = STATE_CONNECTING;
     _fireStateChanged();
 
-    if( !_createNamedPipe( ))
+    const std::string filename = _getFilename();
+    if ( !WaitNamedPipe( filename.c_str(), 20000 )) 
+    { 
+        EQERROR << "Can't create named pipe: " << base::sysError << std::endl; 
+        return false; 
+    }
+
+    if( !_createNamedFile( ))
         return false;
 
     _initAIORead();
@@ -115,12 +122,46 @@ void NamedPipeConnection::close()
 
 bool NamedPipeConnection::_createNamedPipe()
 {
+#if 0
+    SECURITY_ATTRIBUTES sa;
+    sa.lpSecurityDescriptor = 
+        ( PSECURITY_DESCRIPTOR )malloc( SECURITY_DESCRIPTOR_MIN_LENGTH );
+    InitializeSecurityDescriptor( sa.lpSecurityDescriptor, 
+                                  SECURITY_DESCRIPTOR_REVISION );
+    // ACL is set as NULL in order to allow all access to the object.
+    SetSecurityDescriptorDacl( sa.lpSecurityDescriptor, true, 0, false );
+    sa.nLength = sizeof(sa);
+    sa.bInheritHandle = TRUE;
+#endif
+
+    // Start accept
+    const std::string filename = _getFilename();
+    _fd = CreateNamedPipe( 
+                     filename.c_str(),            // pipe name 
+                     PIPE_ACCESS_DUPLEX |         // read/write access 
+                     FILE_FLAG_OVERLAPPED,        // overlapped mode 
+                     PIPE_TYPE_BYTE |             // message-type  
+                     PIPE_READMODE_BYTE |         // message-read  
+                     PIPE_WAIT,                   // blocking mode 
+                     PIPE_UNLIMITED_INSTANCES,    // number of instances 
+                     EQ_PIPE_BUFFER_SIZE,         // output buffer size 
+                     EQ_PIPE_BUFFER_SIZE,         // input buffer size 
+                     0,                           // default time-out (unused)
+                     0 /*&sa*/);                  // default security attributes
+
+    if ( _fd == INVALID_HANDLE_VALUE ) 
+    {
+        EQERROR << "Could not create named pipe: " 
+                << base::sysError << " file : " << filename << std::endl;
+        close();
+        return false;
+    }
+    return true;
+}
+
+bool NamedPipeConnection::_createNamedFile()
+{
     const std::string filename = _getFilename();
-    if ( !WaitNamedPipe( filename.c_str(), 20000 )) 
-    { 
-        EQERROR << "Can't create named pipe: " << base::sysError << std::endl; 
-        return false; 
-    }    
 
     _fd = CreateFile( 
              filename.c_str(),      // pipe name 
@@ -241,41 +282,7 @@ void NamedPipeConnection::acceptNB()
     EQASSERT( _state == STATE_LISTENING );
     ResetEvent( _read.hEvent );
 
-
-#if 0
-    SECURITY_ATTRIBUTES sa;
-    sa.lpSecurityDescriptor = 
-        ( PSECURITY_DESCRIPTOR )malloc( SECURITY_DESCRIPTOR_MIN_LENGTH );
-    InitializeSecurityDescriptor( sa.lpSecurityDescriptor, 
-                                  SECURITY_DESCRIPTOR_REVISION );
-    // ACL is set as NULL in order to allow all access to the object.
-    SetSecurityDescriptorDacl( sa.lpSecurityDescriptor, true, 0, false );
-    sa.nLength = sizeof(sa);
-    sa.bInheritHandle = TRUE;
-#endif
-
-    // Start accept
-    const std::string filename = _getFilename();
-    _fd = CreateNamedPipe( 
-                     filename.c_str(),            // pipe name 
-                     PIPE_ACCESS_DUPLEX |         // read/write access 
-                     FILE_FLAG_OVERLAPPED,        // overlapped mode 
-                     PIPE_TYPE_BYTE |             // message-type  
-                     PIPE_READMODE_BYTE |         // message-read  
-                     PIPE_WAIT,                   // blocking mode 
-                     PIPE_UNLIMITED_INSTANCES,    // number of instances 
-                     EQ_PIPE_BUFFER_SIZE,         // output buffer size 
-                     EQ_PIPE_BUFFER_SIZE,         // input buffer size 
-                     0,                           // default time-out (unused)
-                     0 /*&sa*/);                  // default security attributes
-
-    if ( _fd == INVALID_HANDLE_VALUE ) 
-    {
-        EQERROR << "Could not create named pipe: " 
-                << base::sysError << " file : " << filename << std::endl;
-        close();
-        return;
-    }
+    _createNamedPipe();
 
     _connectToNewClient( _fd );
 }
diff --git a/libs/collage/namedPipeConnection.h b/libs/collage/namedPipeConnection.h
index 69b82e6..cf0d0b7 100644
--- a/libs/collage/namedPipeConnection.h
+++ b/libs/collage/namedPipeConnection.h
@@ -66,7 +66,10 @@ namespace co
         void _exitAIOAccept();
         void _initAIORead();
         void _exitAIORead();
+        bool _createNamedFile();
+        bool _createNamedPipe();
 
+        friend class PipeConnection;
 #ifdef WIN32
         virtual void readNB( void* buffer, const uint64_t bytes );
         virtual int64_t readSync( void* buffer, const uint64_t bytes,
@@ -75,9 +78,8 @@ namespace co
 #else
 
 #endif
-
     private:
-        bool _createNamedPipe();
+
 
 #ifdef WIN32
         HANDLE _fd;
diff --git a/libs/collage/pairConnection.cpp b/libs/collage/pairConnection.cpp
index de46615..b06b67f 100644
--- a/libs/collage/pairConnection.cpp
+++ b/libs/collage/pairConnection.cpp
@@ -31,9 +31,9 @@ PairConnection::PairConnection( ConnectionPtr readConnection,
 }
 
 PairConnection::PairConnection( PairConnection* sibling )
-        : _readConnection( sibling->_writeConnection ),
-          _writeConnection( sibling->_readConnection ),
-          _sibling( sibling )
+        : _readConnection( sibling->_writeConnection )
+        , _writeConnection( sibling->_readConnection )
+        , _sibling( sibling )
 {
     EQASSERT( _readConnection->isClosed( ));
     EQASSERT( _writeConnection->isClosed( ));
diff --git a/libs/collage/pipeConnection.cpp b/libs/collage/pipeConnection.cpp
index cb44cc9..bd16b6c 100644
--- a/libs/collage/pipeConnection.cpp
+++ b/libs/collage/pipeConnection.cpp
@@ -18,20 +18,20 @@
 #include "pipeConnection.h"
 
 #include "connectionDescription.h"
+#include "namedPipeConnection.h"
 #include "node.h"
 
 #include <co/base/log.h>
 #include <co/base/thread.h>
+#include <co/base/uint128_t.h>
 
 namespace co
 {
 
 PipeConnection::PipeConnection()
 #ifdef _WIN32
-        : _readHandle( 0 ),
-          _writeHandle( 0 ),
-          _size( 0 ),
-          _dataPending( CreateEvent( 0, TRUE, FALSE, 0 ))
+        : _readPipe( new NamedPipeConnection() )
+        , _writePipe( new NamedPipeConnection() )
 #endif
 {
     _description->type = CONNECTIONTYPE_PIPE;
@@ -41,13 +41,20 @@ PipeConnection::PipeConnection()
 PipeConnection::~PipeConnection()
 {
 #ifdef _WIN32
-    CloseHandle( _dataPending );
-    _dataPending = 0;
+    close();
+    _writePipe = 0;
+    _readPipe = 0;
 #endif
 }
 
 #ifdef _WIN32
 
+Connection::Notifier PipeConnection::getNotifier() const 
+{ 
+    EQASSERT( _readPipe );
+    return _readPipe->getNotifier(); 
+}
+
 //----------------------------------------------------------------------
 // connect
 //----------------------------------------------------------------------
@@ -59,7 +66,7 @@ bool PipeConnection::connect()
         return false;
 
     _state = STATE_CONNECTING;
-    _size  = 0;
+    _fireStateChanged();
 
     if( !_createPipe( ))
     {
@@ -74,100 +81,69 @@ bool PipeConnection::connect()
 
 bool PipeConnection::_createPipe()
 {
-    if( CreatePipe( &_readHandle, &_writeHandle, 0, 0 ) == 0 )
-    {
-        EQERROR << "Could not create pipe: " << base::sysError 
-                << std::endl;
-        close();
-        return false;
-    }
+    std::stringstream pipeName;
+    pipeName << "\\\\.\\Pipe\\Collage." << co::base::UUID( true );
+
+    EQASSERT( _readPipe );
+    _readPipe->getDescription()->setFilename( pipeName.str() );
+    _readPipe->_initAIOAccept();
+    _readPipe->_createNamedPipe();
+    _readPipe->_state = STATE_CONNECTED;
+
+    EQASSERT( _writePipe );
+    _writePipe = new NamedPipeConnection();
+    _writePipe->getDescription()->setFilename( pipeName.str() );
+    _writePipe->_createNamedFile();
+    _writePipe->_state = STATE_CONNECTED;
+    
     return true;
 }
 
 void PipeConnection::close()
 {
-    if( _writeHandle )
-    {
-        CloseHandle( _writeHandle );
-        _writeHandle = 0;
-    }
-    if( _readHandle )
-    {
-        CloseHandle( _readHandle );
-        _readHandle = 0;
-    }
+    if( !(_state == STATE_CONNECTED || _state == STATE_LISTENING ))
+        return;
+
     _state = STATE_CLOSED;
     _fireStateChanged();
-}
-void PipeConnection::readNB( void* buffer, const uint64_t bytes ) { /* NOP */ }
-int64_t PipeConnection::readSync( void* buffer, const uint64_t bytes,
-                                  const bool ignored )
-{
-    if( !_readHandle )
-        return -1;
+    
+    if( _writePipe )
+        _writePipe->close();
 
-    DWORD bytesRead = 0;
-    const BOOL ret = ReadFile( _readHandle, buffer, static_cast<DWORD>( bytes ),
-                               &bytesRead, 0 );
+    if( _readPipe )
+        _readPipe->close();
+}
 
-    if( ret == 0 ) // Error
-    {
-        EQWARN << "Error during read: " << base::sysError << std::endl;
-        return -1;
-    }
+void PipeConnection::readNB( void* buffer, const uint64_t bytes )
+{
+    if( _state == STATE_CLOSED || !_readPipe )
+        return;
+    _readPipe->readNB( buffer, bytes );
+}
 
-    if( bytesRead == 0 ) // EOF
+int64_t PipeConnection::readSync( void* buffer, const uint64_t bytes,
+                                       const bool ignored )
+{
+    if( !_readPipe )
     {
-        close();
+        EQERROR << "Invalid read pipe" << std::endl;
         return -1;
     }
 
-    _mutex.set();
-    EQASSERT( _size >= bytesRead );
-    _size -= bytesRead;
-    if( _size == 0 )
-        ResetEvent( _dataPending );
-    _mutex.unset();
+    const int64_t bytesRead = _readPipe->readSync( buffer, bytes, ignored );
 
+    if( bytesRead == -1 )
+        close();
+    
     return bytesRead;
 }
 
 int64_t PipeConnection::write( const void* buffer, const uint64_t bytes )
 {
-    if( _state != STATE_CONNECTED || !_writeHandle )
+    if( _state != STATE_CONNECTED || !_writePipe )
         return -1;
 
-    const DWORD size = EQ_MIN( static_cast<DWORD>( bytes ), 4096 );
-
-    _mutex.set();
-    _size += size; // speculatively 'write' everything
-    _mutex.unset();
-
-    DWORD bytesWritten = 0;
-    const BOOL ret = WriteFile( _writeHandle, buffer, size, &bytesWritten, 0 );
-
-    if( ret == 0 ) // Error
-    {
-        EQWARN << "Error during write: " << base::sysError << std::endl;
-        bytesWritten = 0;
-    }
-
-    _mutex.set();
-    EQASSERT( _size >= size - bytesWritten );
-    _size -= ( size - bytesWritten ); // correct size
-
-    if( _size > 0 )
-        SetEvent( _dataPending );
-    else
-    {
-        EQASSERT( _size == 0 );
-        ResetEvent( _dataPending );
-    }
-    _mutex.unset();
-
-    if( ret==0 ) 
-        return -1;
-    return bytesWritten;
+    return _writePipe->write( buffer, bytes );
 }
 
 #else // !_WIN32
diff --git a/libs/collage/pipeConnection.h b/libs/collage/pipeConnection.h
index 2c37908..bb6f5e4 100644
--- a/libs/collage/pipeConnection.h
+++ b/libs/collage/pipeConnection.h
@@ -18,7 +18,7 @@
 #ifndef CO_PIPE_CONNECTION_H
 #define CO_PIPE_CONNECTION_H
 
-#ifdef WIN32
+#ifdef _WIN32
 #  include <co/connection.h>
 #else
 #  include "fdConnection.h"
@@ -28,6 +28,7 @@
 
 namespace co
 {
+    class NamedPipeConnection;
     /**
      * A uni-directional pipe connection.
      *
@@ -36,7 +37,7 @@ namespace co
      * used to create a bi-directional communication using two pipe connections.
      */
     class PipeConnection 
-#ifdef WIN32
+#ifdef _WIN32
         : public Connection
 #else
         : public FDConnection
@@ -51,14 +52,12 @@ namespace co
         virtual bool connect();
         virtual void close();
 
-#ifdef WIN32
-        virtual Notifier getNotifier() const { return _dataPending; }
-        bool hasData() const 
-            { return WaitForSingleObject( _dataPending, 0 ) == WAIT_OBJECT_0; }
+#ifdef _WIN32
+        virtual Notifier getNotifier() const;
 #endif
 
     protected:
-#ifdef WIN32
+#ifdef _WIN32
         virtual void readNB( void* buffer, const uint64_t bytes );
         virtual int64_t readSync( void* buffer, const uint64_t bytes,
                                   const bool ignored );
@@ -68,12 +67,13 @@ namespace co
     private:
         bool _createPipe();
 
-#ifdef WIN32
-        HANDLE _readHandle;
-        HANDLE _writeHandle;
-        mutable base::Lock _mutex;
-        mutable uint64_t   _size;
-        mutable HANDLE     _dataPending;
+#ifdef _WIN32
+        /** A reference pointer for Connection pointers. */
+        typedef base::RefPtr< NamedPipeConnection >   NamePipeConnectionPtr;
+        NamedPipeConnection* _readPipe;
+        NamedPipeConnection* _writePipe;
+
+        EQ_TS_VAR( _recvThread );
 #endif
     };
 }
