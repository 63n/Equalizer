Index: lib/net/connection.cpp
===================================================================
--- lib/net/connection.cpp	(revision 3455)
+++ lib/net/connection.cpp	(working copy)
@@ -192,6 +192,10 @@
 bool Connection::send( const void* buffer, const uint64_t bytes, 
                        const bool isLocked )
 {
+    EQASSERT( bytes > 0 );
+    if( bytes == 0 )
+        return true;
+
     if( _state != STATE_CONNECTED )
         return false;
 
@@ -363,6 +367,27 @@
     }
 }
 
+bool Connection::hasData() const
+{
+    const int fd = getReadFD();
+    if( fd <= 0 )
+        return false;
+
+    fd_set set;
+    FD_ZERO( &set );
+    FD_SET( fd, &set );
+
+    timeval timeout;
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 0;
+
+    const int result = select( fd+1, &set, 0, 0, &timeout );
+    if( result < 0 )
+        EQWARN << "Error during select" << std::endl;
+
+    return ( result > 0 );
+}
+
 std::ostream& operator << ( std::ostream& os, const Connection* connection )
 {
     if( !connection )
Index: lib/net/node.cpp
===================================================================
--- lib/net/node.cpp	(revision 3455)
+++ lib/net/node.cpp	(working copy)
@@ -825,21 +825,26 @@
         node = i->second;
     EQASSERTINFO( !node || node->_connection == connection, 
                   typeid( *node.get( )).name( ));
+    
+    if( !connection->hasData( ))
+        return false;
 
     EQVERB << "Handle data from " << node << endl;
 
-    void* sizePtr( 0 );
+    uint64_t* sizePtr( 0 );
     uint64_t bytes( 0 );
-    const bool gotSize = connection->recvSync( &sizePtr, &bytes );
+    const bool gotSize =
+        connection->recvSync( reinterpret_cast< void ** >( &sizePtr ), &bytes );
+    EQASSERT( sizePtr );
 
     if( !gotSize ) // Some systems signal data on dead connections.
     {
+        *sizePtr = 0;
         connection->recvNB( sizePtr, sizeof( uint64_t ));
         return false;
     }
 
-    EQASSERT( sizePtr );
-    const uint64_t size = *reinterpret_cast< uint64_t* >( sizePtr );
+    const uint64_t size = *sizePtr;
     EQASSERT( size );
     EQASSERT( bytes == sizeof( uint64_t ));
     EQASSERT( size > sizeof( size ));
@@ -855,6 +860,7 @@
     EQASSERT( command.isValid( ));
 
     // start next receive
+    *sizePtr = 0;
     connection->recvNB( sizePtr, sizeof( uint64_t ));
 
     if( !gotData )
Index: lib/net/socketConnection.h
===================================================================
--- lib/net/socketConnection.h	(revision 3455)
+++ lib/net/socketConnection.h	(working copy)
@@ -60,6 +60,7 @@
 #ifdef WIN32
         /** @sa Connection::getNotifier */
         virtual Notifier getNotifier() const { return _overlapped.hEvent; }
+        virtual int getReadFD() const { return _readFD; }
 #endif
 
     protected:
Index: lib/net/pipeConnection.h
===================================================================
--- lib/net/pipeConnection.h	(revision 3455)
+++ lib/net/pipeConnection.h	(working copy)
@@ -55,7 +55,7 @@
 
 #ifdef WIN32
         virtual Notifier getNotifier() const { return _dataPending; }
-        bool hasData() const 
+        virtual bool hasData() const 
             { return WaitForSingleObject( _dataPending, 0 ) == WAIT_OBJECT_0; }
 #endif
 
Index: lib/net/fdConnection.h
===================================================================
--- lib/net/fdConnection.h	(revision 3455)
+++ lib/net/fdConnection.h	(working copy)
@@ -34,6 +34,7 @@
     public:
 #ifndef WIN32
         virtual Notifier getNotifier() const { return _readFD; }
+        virtual int getReadFD() const { return _readFD; }
 #endif
 
         bool hasData() const;
Index: lib/net/pairConnection.h
===================================================================
--- lib/net/pairConnection.h	(revision 3455)
+++ lib/net/pairConnection.h	(working copy)
@@ -41,6 +41,8 @@
 
         virtual Notifier getNotifier() const
             { return _readConnection->getNotifier(); }
+        virtual int getReadFD() const { return _readConnection->getReadFD(); }
+        virtual bool hasData() const { return _readConnection->hasData(); }
 
     protected:
         EQ_EXPORT virtual ~PairConnection();
Index: lib/net/namedPipeConnection.h
===================================================================
--- lib/net/namedPipeConnection.h	(revision 3455)
+++ lib/net/namedPipeConnection.h	(working copy)
@@ -58,6 +58,8 @@
 #ifdef WIN32
         virtual Notifier getNotifier() const {
             return _read.hEvent; }
+        virtual bool hasData() const 
+            { return WaitForSingleObject( _read.hEvent, 0 ) == WAIT_OBJECT_0; }
 #endif
 
     protected:
Index: lib/net/connection.h
===================================================================
--- lib/net/connection.h	(revision 3455)
+++ lib/net/connection.h	(working copy)
@@ -348,6 +348,9 @@
         /** @return the notifier signalling events on the connection. */
         virtual Notifier getNotifier() const { return 0; }
 
+        virtual int getReadFD() const { return 0; }
+        virtual bool hasData() const;
+
     protected:
         Connection();
         virtual ~Connection();
Index: lib/net/socketConnectionWin32.cpp
===================================================================
--- lib/net/socketConnectionWin32.cpp	(revision 3455)
+++ lib/net/socketConnectionWin32.cpp	(working copy)
@@ -257,7 +257,6 @@
     DWORD  got   = 0;
     DWORD  flags = 0;
 
-    ResetEvent( _overlapped.hEvent );
     if( WSARecv( _readFD, &wsaBuffer, 1, &got, &flags, &_overlapped, 0 ) != 0 &&
         GetLastError() != WSA_IO_PENDING )
     {
@@ -277,28 +276,38 @@
         return -1;
     }
 
-    DWORD got   = 0;
-    DWORD flags = 0;
-    if( !WSAGetOverlappedResult( _readFD, &_overlapped, &got, TRUE, &flags ))
-    {
-        if( GetLastError() == WSASYSCALLFAILURE ) // happens sometimes!?
-            return 0;
-
-        EQWARN << "Read complete failed: " << EQ_SOCKET_ERROR 
-               << ", closing connection" << std::endl;
-        close();
-        return -1;
-    }
+    EQASSERT( _overlapped.hEvent );
+    ResetEvent( _overlapped.hEvent );
 
-    if( got == 0 )
+    while( true )
     {
-        EQWARN << "Read operation returned with nothing read"
-               << ", closing connection." << std::endl;
-        close();
-        return -1;
-    }
+        DWORD got   = 0;
+        DWORD flags = 0;
+        if( !WSAGetOverlappedResult( _readFD, &_overlapped, &got, TRUE, &flags))
+        {
+            if( GetLastError() == WSASYSCALLFAILURE ) // happens sometimes!?
+            {
+                EQWARN << "Got WSASYSCALLFAILURE, buffer has "
+                       << reinterpret_cast< uint64_t* >(buffer)[0] << std::endl;
+                continue;
+            }
+
+            EQWARN << "Read complete failed: " << EQ_SOCKET_ERROR 
+                   << ", closing connection" << std::endl;
+            close();
+            return -1;
+        }
+        
+        if( got == 0 )
+        {
+            EQWARN << "Read operation returned with nothing read"
+                   << ", closing connection." << std::endl;
+            close();
+            return -1;
+        }
 
-    return got;
+        return got;
+    }
 }
 
 int64_t SocketConnection::write( const void* buffer, const uint64_t bytes)
