static const std::string vertexShader_glsl = "/* Copyright (c) 2007       Maxim Makhinya\n    All rights reserved. */\n \n \n // updated per frame\n uniform vec3    vecView;\n uniform int     frontIndex;\n uniform float   sliceDistance;\n \n \n uniform float   W;   //scale for x\n uniform float   H;   //scale for y\n uniform float   D;   //scale for z\n uniform float   Do;  //shift of z\n uniform float   Db;  //z offset \n \n \n void main(void)\n {\n //    gl_Position = ftransform();\n     gl_Position = gl_ModelViewProjectionMatrix * vec4( gl_Vertex.xyz, 1.0 );\n \n     gl_TexCoord[0] = 0.5 * gl_Vertex + 0.5;\n \n     vec4 vDir = normalize(gl_ModelViewMatrixInverse * vec4(0.,0.,-1.,1.));\n \n #ifndef PARALLEL_PROJECTION\n     //compute position of virtual back vertex\n     vec4 vPosition = gl_ModelViewMatrixInverse*vec4(0,0,0,1);\n \n     vec4 eyeToVert = normalize(gl_Vertex - vPosition);\n     vec4 backVert = vec4(1,1,1,1);\n \n     gl_TexCoord[1] =\n             gl_Vertex + eyeToVert * (sliceDistance / dot(vDir,eyeToVert));\n #else\n     gl_TexCoord[1] = gl_Vertex + vDir * sliceDistance; \n #endif\n     //compute texture coordinates for virtual back vertex\n \n     gl_TexCoord[1] = 0.5 * gl_TexCoord[1] + 0.5;\n \n \n //Scaling of texture coordinates\n     gl_TexCoord[0].x  *= W;\n     gl_TexCoord[0].y  *= H;\n     gl_TexCoord[0].z   = Db + (gl_TexCoord[0].z - Do) * D;\n \n     gl_TexCoord[1].x  *= W;\n     gl_TexCoord[1].y  *= H;\n     gl_TexCoord[1].z   = Db + (gl_TexCoord[1].z - Do) * D;\n \n }\n ";
