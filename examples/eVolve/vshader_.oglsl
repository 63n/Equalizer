
// updated per frame
uniform vec3  vecView;
uniform int   frontIndex;

// const: never updated
uniform float sliceDistance;

uniform float dPlaneStart;
uniform float dPlaneIncr;
uniform int   sequence[64];
uniform vec3  vecVertices[8];
uniform int   v1[24];
uniform int   v2[24];

varying vec4 coll;

void main(void)
{
	vec3 vecTranslate = vec3( 0.0, 0.0, 0.0 );

/*	vec3 vcolor;
	if (gl_Vertex.x == 0.0) {
		vcolor = vec3(1.0,0.0,0.0);
	} else if (gl_Vertex.x == 1.0) {
		vcolor = vec3(1.0,1.0,0.0);
	} else if (gl_Vertex.x == 2.0) {
		vcolor = vec3(0.0,1.0,0.0);
	} else if (gl_Vertex.x == 3.0) {
		vcolor = vec3(0.0,1.0,1.0);
	} else if (gl_Vertex.x == 4.0) {
		vcolor = vec3(0.0,0.0,1.0);
	} else if (gl_Vertex.x == 5.0) {
		vcolor = vec3(1.0,0.0,1.0);
	} 
	coll = vcolor;
*/

    float dPlaneDist = dPlaneStart + gl_Vertex.y * dPlaneIncr;
        
    vec3 Position  = vecTranslate;
    
    for( int e = 0; e < 4; e++ )
	{
    
		int vidx1 = sequence[ int( frontIndex * 8 + v1[ int( gl_Vertex.x ) * 4 + e ] ) ];
		int vidx2 = sequence[ int( frontIndex * 8 + v2[ int( gl_Vertex.x ) * 4 + e ] ) ];
    
		vec3 vecV1 = vecVertices[ vidx1 ];
		vec3 vecV2 = vecVertices[ vidx2 ];
        
		vec3 vecStart = vecV1 + vecTranslate;
		vec3 vecDir   = vecV2 - vecV1;
    
		float denom = dot( vecDir, vecView );
		float lambda = ( denom != 0.0 ) ? ( dPlaneDist - dot( vecStart, vecView ) ) / denom : -1.0;

//		if( (lambda >= -0.005) && (lambda <= 1.005) )
		if( (lambda >= -0.00015) && (lambda <= 1.00015) )
		{
			lambda = clamp( lambda, 0.0, 1.0 );
			Position = vecStart + lambda * vecDir;
			break;
		}
		
    } 
	
	vec4 vertex = vec4( Position, 1.0 );
	
	if( abs(Position.x) <= 0.1 && abs(Position.y) <= 0.1 && abs(Position.z) <= 0.1 )
		coll = vec4( 1.0, 0.0, 0.0, 1.0 );
	else
		coll = vec4( 0.3, 0.3, 0.3, 0.1 );
	
	gl_Position   = gl_ModelViewProjectionMatrix * vertex;
/*	
	gl_TexCoord[0] = vertex / 2.0 + 0.5;
	
	vec4 vPosition = gl_ModelViewMatrixInverse*vec4(0,0,0,1);
	vec3 vDir = normalize(gl_NormalMatrix * vec3(0.,0.,-1.));

	//compute position of virtual back vertex
	vec3 eyeToVert = normalize(Position - vPosition.xyz);

	float cos = sliceDistance * 10.0;// / max( dot( vDir, eyeToVert ), 0.001 );
	vec4 backV     = vertex + (vec4( eyeToVert, 0.0) * cos ); 
	
	//compute texture coordinates for virtual back vertex
	
	gl_TexCoord[1] = backV / 2.0 + 0.5;
*/	
}

/*
uniform float sliceDistance;

void main(void)
{
	gl_ClipVertex = gl_ModelViewMatrix * gl_Vertex;
	
	gl_Position = ftransform();
	
	gl_TexCoord[0] = gl_TextureMatrixInverse[0] * gl_Vertex;
	gl_TexCoord[0] = gl_TexCoord[0] / 2.0 + 0.5;
	
	vec4 vPosition = gl_ModelViewMatrixInverse*vec4(0,0,0,1);
	vec4 vDir = normalize(gl_ModelViewMatrixInverse * vec4(0.,0.,-1.,1.));

	//compute position of virtual back vertex
	
	vec4 eyeToVert = normalize(gl_Vertex - vPosition);
	vec4 backVert = vec4(1,1,1,1);
	backVert = gl_Vertex - eyeToVert * (sliceDistance / dot(vDir,eyeToVert)); 
	
	//compute texture coordinates for virtual back vertex
	
	gl_TexCoord[1] = gl_TextureMatrixInverse[0] * backVert;
	gl_TexCoord[1] = gl_TexCoord[1] / 2.0 + 0.5;
}
*/