static const std::string vertexShaderSimple_cg = "\n //#define PARALLEL_PROJECTION\n \n #define ZERO 0.0\n #define ONE  1.0\n \n void main(\n     float3 Position: POSITION,\n \n     // updated per frame\n     uniform float3  vecView,\n     uniform int     frontIndex,\n     uniform half    sliceDistance,\n \n     uniform float   W,   //scale for x\n     uniform float   H,   //scale for y\n     uniform float   D,   //scale for z\n     uniform float   Do,  //shift of z\n     uniform float   Db,  //z offset \n \n     // output variables\n     out float4  VertexOut : POSITION,\n     out float3  frontP    : TEXCOORD0,\n     out float3  backP     : TEXCOORD1\n )\n {\n     VertexOut = mul( glstate.matrix.mvp, float4( Position, 1.0) );\n \n     frontP = 0.5 * Position + 0.5;\n     \n     float4 vDir = normalize( \n             mul( glstate.matrix.inverse.modelview[0], float4(0.,0.,-1.,1.) ) );\n \n #ifndef PARALLEL_PROJECTION\n     float4 vPosition = \n         mul( glstate.matrix.inverse.modelview[0], float4(0,0,0,1) );\n \n     //compute position of virtual back vertex\n     float4 eyeToVert = normalize( float4( Position, 1.0) - vPosition );\n \n     backP = Position + eyeToVert * ( sliceDistance / dot( vDir, eyeToVert ) ); \n #else\n     backP = Position + vDir * sliceDistance; \n #endif\n     //compute texture coordinates for virtual back vertex\n \n     backP = 0.5 * backP + 0.5;\n \n //Scaling of texture coordinates\n     frontP.x *= W;\n     frontP.y *= H;\n     frontP.z  = Db + (frontP.z - Do) * D;\n \n     backP.x  *= W;\n     backP.y  *= H;\n     backP.z   = Db + (backP.z  - Do) * D;\n \n     return;\n }\n ";
