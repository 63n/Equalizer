
//#define PARALLEL_PROJECTION

#define ZERO 0.0
#define ONE  1.0

void main(
    float3 Position: POSITION,

    // updated per frame
    uniform float3  vecView,
    uniform int     frontIndex,
    uniform half    sliceDistance,

    uniform float   W,   //scale for x
    uniform float   H,   //scale for y
    uniform float   D,   //scale for z
    uniform float   Do,  //shift of z
    uniform float   Db,  //z offset 

    // output variables
    out float4  VertexOut : POSITION,
    out float3  frontP    : TEXCOORD0,
    out float3  backP     : TEXCOORD1
)
{
    VertexOut = mul( glstate.matrix.mvp, float4( Position, 1.0) );

    frontP = 0.5 * Position + 0.5;
    
    float4 vDir = normalize( 
            mul( glstate.matrix.inverse.modelview[0], float4(0.,0.,-1.,1.) ) );

#ifndef PARALLEL_PROJECTION
    float4 vPosition = 
        mul( glstate.matrix.inverse.modelview[0], float4(0,0,0,1) );

    //compute position of virtual back vertex
    float4 eyeToVert = normalize( float4( Position, 1.0) - vPosition );

    backP = Position + eyeToVert * ( sliceDistance / dot( vDir, eyeToVert ) ); 
#else
    backP = Position + vDir * sliceDistance; 
#endif
    //compute texture coordinates for virtual back vertex

    backP = 0.5 * backP + 0.5;

//Scaling of texture coordinates
    frontP.x *= W;
    frontP.y *= H;
    frontP.z  = Db + (frontP.z - Do) * D;

    backP.x  *= W;
    backP.y  *= H;
    backP.z   = Db + (backP.z  - Do) * D;

    return;
}
