static const std::string vertexShaderComplex_cg = "\n //#define PARALLEL_PROJECTION\n \n #define ZERO 0.0\n #define ONE  1.0\n \n void main(\n     int2  VindexAndSlice : POSITION, \n     float3 color         : COLOR,\n       \n     // updated per cube\n           \n     // updated per frame\n     uniform float3   vecView,\n     uniform int      frontIndex,\n     uniform half sliceDistance,\n           \n     // const: never updated\n     uniform float   dPlaneStart,\n     uniform int     sequence[64],\n     uniform float3  vecVertices[8],\n     uniform int   v1[24],\n     uniform int   v2[24],\n \n \n     uniform float   W,   //scale for x\n     uniform float   H,   //scale for y\n     uniform float   D,   //scale for z\n     uniform float   Do,  //shift of z\n     uniform float   Db,  //z offset \n \n \n     // output variables\n     out float4  VertexOut : POSITION,\n     out float3  frontP    : TEXCOORD0,\n     out float3  backP     : TEXCOORD1\n )\n {\n     float3   vecTranslate = float3( 0.0, 0.0, 0.0 );\n \n     float dPlaneDist = dPlaneStart + VindexAndSlice.y * sliceDistance;\n \n     float3 Position = vecTranslate;\n     \n     for(int e = 0; e < 4; ++e)\n     {\n         int vidx1 = sequence[int(frontIndex * 8 + v1[VindexAndSlice.x*4+e])];\n         int vidx2 = sequence[int(frontIndex * 8 + v2[VindexAndSlice.x*4+e])];\n \n         float3 vecV1 = vecVertices[vidx1];\n         float3 vecV2 = vecVertices[vidx2];\n         \n         float3 vecStart = vecV1+vecTranslate;\n         float3 vecDir   = vecV2-vecV1;\n \n         float denom = dot(vecDir,vecView);\n         float lambda = \n             (denom != 0.0) ? (dPlaneDist - dot(vecStart,vecView))/denom : -1.0;\n \n         if ((lambda >= ZERO) && (lambda <= ONE))\n         {\n             Position = vecStart + lambda * vecDir;\n             break;\n         }\n     } \n \n     VertexOut = mul( glstate.matrix.mvp, float4( Position, 1.0) );\n \n     frontP = 0.5 * Position + 0.5;\n     \n     float4 vDir = normalize( \n             mul( glstate.matrix.inverse.modelview[0], float4(0.,0.,-1.,1.) ) );\n \n #ifndef PARALLEL_PROJECTION\n     float4 vPosition = \n         mul( glstate.matrix.inverse.modelview[0], float4(0,0,0,1) );\n \n     //compute position of virtual back vertex\n     float4 eyeToVert = normalize( float4( Position, 1.0) - vPosition );\n \n     backP = Position + eyeToVert * ( sliceDistance / dot( vDir, eyeToVert ) ); \n #else\n     backP = Position + vDir * sliceDistance; \n #endif\n     //compute texture coordinates for virtual back vertex\n \n     backP = 0.5 * backP + 0.5;\n \n //Scaling of texture coordinates\n     frontP.x *= W;\n     frontP.y *= H;\n     frontP.z  = Db + (frontP.z - Do) * D;\n \n     backP.x  *= W;\n     backP.y  *= H;\n     backP.z   = Db + (backP.z  - Do) * D;\n \n     return;\n }\n ";
